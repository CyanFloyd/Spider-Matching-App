# Spider Weight Matching Application

## Overview

This is a full-stack web application designed for managing tournament fighter entries and generating weight-based matches. The application provides a user-friendly interface for tournament organizers to add fighters, assign them to teams, and automatically generate optimal fight matchups based on weight categories with team conflict avoidance.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Build Tool**: Vite with custom configuration for client-side bundling
- **Routing**: Wouter for lightweight client-side routing
- **UI Components**: Shadcn/ui component library built on Radix UI primitives
- **Styling**: Tailwind CSS with custom CSS variables for theming
- **State Management**: TanStack Query (React Query) for server state management
- **Form Handling**: React Hook Form with Zod validation

### Backend Architecture
- **Runtime**: Node.js with Express.js framework
- **Language**: TypeScript with ES modules
- **Database**: PostgreSQL with Drizzle ORM
- **Database Provider**: Neon Database (@neondatabase/serverless)
- **Development**: TSX for TypeScript execution in development
- **Production Build**: ESBuild for server bundling

### Monorepo Structure
- `client/` - Frontend React application
- `server/` - Backend Express.js application  
- `shared/` - Shared TypeScript schemas and types
- `migrations/` - Database migration files (generated by Drizzle)

## Key Components

### Database Schema (`shared/schema.ts`)
- **Entries Table**: Stores fighter information (id, name, teamColor, weight)
- **Matches Table**: Stores generated match pairings (id, fightNumber, fighter1Id, fighter2Id, weightClass, matchType)
- **Validation**: Zod schemas for runtime type checking and API validation

### Storage Layer (`server/storage.ts`)
- **Interface-based Design**: IStorage interface for data operations
- **In-Memory Implementation**: MemStorage class for development/testing
- **Database Ready**: Structure prepared for PostgreSQL integration

### API Routes (`server/routes.ts`)
- **RESTful Design**: Standard HTTP methods for CRUD operations
- **Entry Management**: GET, POST, DELETE endpoints for fighter entries
- **Match Generation**: Endpoints for creating and retrieving matches
- **Error Handling**: Zod validation with proper error responses

### Frontend Components
- **EntryForm**: Form for adding new fighters with team color selection
- **EntriesTable**: Display and management of fighter entries
- **MatchResults**: Display of generated fight matchups
- **UI Components**: Comprehensive Shadcn/ui component library

## Data Flow

### Entry Creation Flow
1. User fills out fighter form (name, team color, weight)
2. Frontend validates data using Zod schema
3. POST request sent to `/api/entries`
4. Backend validates and stores entry
5. React Query invalidates cache and refetches data
6. UI updates with new entry

### Match Generation Flow
1. Tournament organizer triggers match generation
2. Algorithm processes all entries by weight priority
3. Exact weight matches prioritized over tolerance matches
4. Same-team conflicts automatically avoided
5. Generated matches stored in database
6. Results displayed with fight numbers and weight classes

## External Dependencies

### Frontend Dependencies
- **React Ecosystem**: React, React DOM, React Hook Form
- **UI Framework**: Radix UI primitives, Lucide React icons
- **Styling**: Tailwind CSS, Class Variance Authority
- **Data Fetching**: TanStack Query
- **Validation**: Zod with Hookform resolvers
- **Date Handling**: date-fns
- **Routing**: Wouter

### Backend Dependencies
- **Core**: Express.js, TypeScript
- **Database**: Drizzle ORM, Neon Database client
- **Development**: TSX for development server
- **Build**: ESBuild for production bundling
- **Session**: connect-pg-simple for PostgreSQL session store

### Development Tools
- **Build System**: Vite with React plugin
- **TypeScript**: Strict configuration with path mapping
- **Linting**: ESLint configuration for React and TypeScript
- **Database**: Drizzle Kit for migrations and schema management

## Deployment Strategy

### Development Environment
- **Local Development**: `npm run dev` runs TSX server with hot reload
- **Port Configuration**: Server runs on port 5000 with external port 80
- **Vite Integration**: Development middleware for client-side hot reload
- **Database**: Configured for PostgreSQL with environment variable

### Production Build
- **Client Build**: Vite builds React app to `dist/public`
- **Server Build**: ESBuild bundles server to `dist/index.js`
- **Start Command**: `npm run start` runs production server
- **Deployment Target**: Autoscale deployment with build/run commands

### Mobile App Deployment Options

#### Option 1: Progressive Web App (PWA) - Recommended
- **Advantages**: No app store approval, works on all devices, easy deployment
- **Implementation**: Add PWA manifest and service worker to existing React app
- **Installation**: Users can "Add to Home Screen" from browser
- **Features**: Offline capability, push notifications, native-like experience

#### Option 2: Capacitor (Cross-Platform Native)
- **Framework**: Ionic Capacitor wraps the web app in native container
- **Platforms**: iOS, Android from single codebase
- **Implementation**: Minimal changes to existing React app
- **Features**: Access to native device APIs, app store distribution

#### Option 3: React Native (Full Native Rewrite)
- **Approach**: Rewrite frontend using React Native
- **Advantages**: Full native performance and features
- **Disadvantages**: Requires significant development time
- **Backend**: Keep existing Express.js API unchanged

### Environment Configuration
- **Database URL**: Required `DATABASE_URL` environment variable
- **Module System**: ES modules throughout the application
- **Node Version**: Configured for Node.js 20

## Changelog

```
Changelog:
- June 20, 2025. Initial setup
- June 20, 2025. Updated weight validation to 3 digits only (100-999)
- June 20, 2025. Implemented maximum 2 fights per fighter limit
- June 20, 2025. Enhanced matching algorithm with better fight distribution
- June 20, 2025. Added fighter name retention for fast data entry (max 20 per name/color)
- June 20, 2025. Added tolerance matching within Â±3 weight range
```

## User Preferences

```
Preferred communication style: Simple, everyday language.
```